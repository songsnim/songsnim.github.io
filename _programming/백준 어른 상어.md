볼

---
create:: 2023-02-02 Thu 14:35:38
---
#코테/삼성   #python 
url : [19237번: 어른 상어 (acmicpc.net)](https://www.acmicpc.net/problem/19237)
### 문제 설명
[[백준 청소년 상어]]는 더욱 자라 어른 상어가 되었다. 상어가 사는 공간에 더 이상 물고기는 오지 않고 다른 상어들만이 남아있다. 상어에는 1 이상 M 이하의 자연수 번호가 붙어 있고, 모든 번호는 서로 다르다. 상어들은 영역을 사수하기 위해 다른 상어들을 쫓아내려고 하는데, 1의 번호를 가진 어른 상어는 가장 강력해서 나머지 모두를 쫓아낼 수 있다.

N×N 크기의 격자 중 M개의 칸에 상어가 한 마리씩 들어 있다. 맨 처음에는 모든 상어가 자신의 위치에 자신의 냄새를 뿌린다. 그 후 1초마다 모든 상어가 동시에 상하좌우로 인접한 칸 중 하나로 이동하고, 자신의 냄새를 그 칸에 뿌린다. 냄새는 상어가 k번 이동하고 나면 사라진다.

각 상어가 이동 방향을 결정할 때는, 먼저 인접한 칸 중 아무 냄새가 없는 칸의 방향으로 잡는다. 그런 칸이 없으면 자신의 냄새가 있는 칸의 방향으로 잡는다. 이때 가능한 칸이 여러 개일 수 있는데, 그 경우에는 특정한 우선순위를 따른다. 우선순위는 상어마다 다를 수 있고, 같은 상어라도 현재 상어가 보고 있는 방향에 따라 또 다를 수 있다. 상어가 맨 처음에 보고 있는 방향은 입력으로 주어지고, 그 후에는 방금 이동한 방향이 보고 있는 방향이 된다.

모든 상어가 이동한 후 한 칸에 여러 마리의 상어가 남아 있으면, 가장 작은 번호를 가진 상어를 제외하고 모두 격자 밖으로 쫓겨난다. |300

![|300](https://upload.acmicpc.net/149aa507-f474-43cb-9071-1959bb83d59a/-/preview/)

![[Pasted image 20230408201406.png]]

<그림 1>은 맨 처음에 모든 상어가 자신의 냄새를 뿌린 상태를 나타내며, <표 1>에는 각 상어 및 현재 방향에 따른 우선순위가 표시되어 있다. 이 예제에서는 k = 4이다. 왼쪽 하단에 적힌 정수는 냄새를 의미하고, 그 값은 사라지기까지 남은 시간이다. 좌측 상단에 적힌 정수는 상어의 번호 또는 냄새를 뿌린 상어의 번호를 의미한다.

![|500](https://upload.acmicpc.net/b2d80580-57ba-419b-9d16-bc7fbe49512b/-/preview/)

<그림 2>

![|500](https://upload.acmicpc.net/52324aeb-3f7d-49b0-8128-560eb3742aa3/-/preview/)

<그림 3>

<그림 2>는 모든 상어가 한 칸 이동하고 자신의 냄새를 뿌린 상태이고, <그림 3>은 <그림 2>의 상태에서 한 칸 더 이동한 것이다. (2, 4)에는 상어 2과 4가 같이 도달했기 때문에, 상어 4는 격자 밖으로 쫓겨났다.

![|500](https://upload.acmicpc.net/86821cd6-b638-43a1-8abb-99c917d6d324/-/preview/)

<그림 4>

![|500](https://upload.acmicpc.net/76e735b6-44e1-437c-9b69-b7f55ea29d02/-/preview/)

<그림 5>

<그림 4>은 격자에 남아있는 모든 상어가 한 칸 이동하고 자신의 냄새를 뿌린 상태, <그림 5>는 <그림 4>에서 한 칸 더 이동한 상태를 나타낸다. 상어 2는 인접한 칸 중에 아무 냄새도 없는 칸이 없으므로 자신의 냄새가 들어있는 (2, 4)으로 이동했다. 상어가 이동한 후에, 맨 처음에 각 상어가 뿌린 냄새는 사라졌다.

이 과정을 반복할 때, 1번 상어만 격자에 남게 되기까지 몇 초가 걸리는지를 구하는 프로그램을 작성하시오.
#### 입력

첫 줄에는 N, M, k가 주어진다. (2 ≤ N ≤ 20, 2 ≤ M ≤ N2, 1 ≤ k ≤ 1,000)

그 다음 줄부터 N개의 줄에 걸쳐 격자의 모습이 주어진다. 0은 빈칸이고, 0이 아닌 수 x는 x번 상어가 들어있는 칸을 의미한다.

그 다음 줄에는 각 상어의 방향이 차례대로 주어진다. 1, 2, 3, 4는 각각 위, 아래, 왼쪽, 오른쪽을 의미한다.

그 다음 줄부터 각 상어의 방향 우선순위가 상어 당 4줄씩 차례대로 주어진다. 각 줄은 4개의 수로 이루어져 있다. 하나의 상어를 나타내는 네 줄 중 첫 번째 줄은 해당 상어가 위를 향할 때의 방향 우선순위, 두 번째 줄은 아래를 향할 때의 우선순위, 세 번째 줄은 왼쪽을 향할 때의 우선순위, 네 번째 줄은 오른쪽을 향할 때의 우선순위이다. 각 우선순위에는 1부터 4까지의 자연수가 한 번씩 나타난다. 가장 먼저 나오는 방향이 최우선이다. 예를 들어, 우선순위가 1 3 2 4라면, 방향의 순서는 위, 왼쪽, 아래, 오른쪽이다.

맨 처음에는 각 상어마다 인접한 빈 칸이 존재한다. 따라서 처음부터 이동을 못 하는 경우는 없다.

#### 출력

1번 상어만 격자에 남게 되기까지 걸리는 시간을 출력한다. 단, 1,000초가 넘어도 다른 상어가 격자에 남아 있으면 -1을 출력한다.

````col
```col-md
flexGrow=1
===
#### 예시 입출력
5 4 4
0 0 0 0 3
0 2 0 0 0
1 0 0 0 4
0 0 0 0 0
0 0 0 0 0
4 4 3 1
2 3 1 4
4 1 2 3
3 4 2 1
4 3 1 2
2 4 3 1
2 1 3 4
3 4 1 2
4 1 2 3
4 3 2 1
1 4 3 2
1 3 2 4
3 2 1 4
3 4 1 2
3 2 4 1
1 4 2 3
1 4 2 3
```
```col-md
flexGrow=1
===
#### 예시 입출력 설명
14
```
````

### Code
```python
'''
1. 두 상어가 같은 칸에 도착하면 번호 가장 낮은 놈 제외 모두 사라진다.
2. 칸에 도착하면 자기 냄새를 뿌린다.
    냄새는 상어가 k번 이동하면 사라진다.
3. 상어가 상하좌우 중 하나로 이동한다.
    - 냄새가 없는 칸으로 이동한다.
    - 모두 냄새가 있으면 자기 냄새가 있는 곳으로 이동한다.
    - 자기 냄새가 여러군데 있으면 각자 우선순위에 따라 이동한다.
        - 우선순위는 바라보고 있는 방향에 따라 달라진다.
    - 이동하면 이동한 방향으로 바라본다.

4. 1번 상어만 격자에 남게 되기 까지 걸리는 시간을 출력한다.
    단 1000초 넘어도 다른 상어가 남아있으면 -1을 출력한다.
'''

N, M, K = map(int, input().split(' '))
board = []
for _ in range(N):
    board.append(list(map(int, input().split(' '))))

direc = [[0]]+list(map(int, input().split(' '))) # 초기 상어의 방향

which = [[[0,0]]*N for _ in range(N)] # 각 칸마다 (상어번호, 방향) 매겨져있음
smell = [[[0,0]]*N for _ in range(N)] # 각 칸마다 (상어번호, 냄새) 매겨져있음

# 상어 초기 위치 설정
for x in range(N):
    for y in range(N):
        if board[x][y] > 0:
            shark = board[x][y]
            which[x][y] = [shark, direc[shark]]
            
# 상어 우선순위 목록 만들기
d_prior = [[]]
for shark in range(1,M+1):
    temp = [] # 상어 하나 -> 상 하 좌 우 를 보고 있을 때 우선순위
    for d in range(4): 
        temp.append(list(map(int, input().split(' '))))
    d_prior.append([[]]+temp)

'''
which[x][y] -> [상어번호, 상어방향]
smell[x][y] -> [상어번호, 냄새]
d_prior[상어번호][상어방향] -> 해당 상어 이동할 방향 우선순위
'''

# 냄새 업데이트 용
def update_smell():
    for x in range(N):
        for y in range(N):
            if smell[x][y][1] > 0: # 냄새가 있으면
                smell[x][y][1] -= 1 # 하나 줄이기
            if which[x][y][1] != 0: #상어가 있으면
                smell[x][y] = [which[x][y][0],K] # 방구끼기

#상 하 좌 우
direc = ((0,0),(-1,0), (1,0), (0,-1), (0,1)) 

def one_sec():
    moved = [-1]+[False]*M # 이미 움직인 상어는 안건드리기 위해 선언
    for x in range(N):
        for y in range(N): # 각 칸마다
            if which[x][y][0] > 0: # 상어가 있으면 움직일건데 
                s_n, s_d = which[x][y]
                if moved[s_n] == False: # 아직 안 움직인 상어여야 해 
                    allsmell = 0 # 
                    for d in d_prior[s_n][s_d]: # 우선순위 방향부터 살펴볼건데
                        nx = x + direc[d][0] 
                        ny = y + direc[d][1] 
                        if 0<=nx<N and 0<=ny<N and smell[nx][ny][1] == 0: # 냄새가 없어서 이동가능하고 
                            if 0<which[nx][ny][0] < which[x][y][0]: # 가는 곳에 상어가 있는데 나보다 강한놈이면
                                which[x][y] = [0,0] # 뭐 더 할거 없고 걍 상어 없애기
                                moved[s_n] = True # 움직인 상어 기록
                            else:
                                which[nx][ny] = [which[x][y][0], d] # 나보다 약하면 먹으러 간다.
                                which[x][y] = [0,0] # 원래 있던 곳은 비우고 
                                moved[s_n] = True # 움직인 상어 기록
                            break
                        allsmell += 1 # 해당 방향에 냄새가 있는지 체크
                    
                    if allsmell == 4: # 모든 방향에 냄새가 있으면
                        for d in d_prior[s_n][s_d]: # 다시 우선 방향부터 살필건데 
                            nx = x + direc[d][0]
                            ny = y + direc[d][1] # 이동
                            if 0<=nx<N and 0<=ny<N and smell[nx][ny][0] == which[x][y][0]: # 냄새의 주인이 자기거면 
                                which[nx][ny] = [which[x][y][0], d] # 간다!
                                which[x][y] = [0,0]
                                moved[s_n] = True
                                break

# 냄새 초기값 설정
for x in range(N):
    for y in range(N):
        if which[x][y][0] > 0:
            smell[x][y] = [which[x][y][0], K]

TIME = 0

while True:
    TIME += 1 # 시간 흐르는 중
    one_sec() # 1초 지나고
    update_smell() # 냄새 업데이트
    left_shark = 0
    for x in range(N):
        for y in range(N):
            if which[x][y][0] > 0: 
                left_shark += 1

    if left_shark == 1: # 남은 상어가 하나면
        print(TIME) # 끝!
        break
    
    if TIME >= 1000: # 1000초가 지나면
        print(-1) # 끝! 
        break


```

## Links
